# no-build-next — Project Plan

## Project Overview

**no-build-next** is a frontend framework that replicates core Next.js App Router functionality (file-based routing, layouts, loading states, error boundaries, client/server component separation) but eliminates the traditional build/bundle step during development. Instead of running a dev server that watches, transpiles, and bundles files on every change, this project serves source files directly to the browser using native ES modules, import maps, and a lightweight HTTP server.

The result: dev server startup in **< 1 second**, and file changes visible in the browser in **< 1 second** — regardless of project size.

**Back-end functionality (API routes, server actions, server-side data fetching) is explicitly out of scope.** This is a front-end-only framework for now.

## Goals & Success Criteria

1. **Dev server starts in < 1 second** — The server process should be ready to serve pages almost instantly. No upfront compilation or bundling.
2. **File changes appear in browser in < 1 second** — Saving a file should trigger a near-instant update in the browser (via HMR or live reload).
3. **Next.js App Router conventions** — Support the file-based routing conventions developers already know:
   - `app/` directory with `page.tsx`, `layout.tsx`, `loading.tsx`, `error.tsx`, `not-found.tsx`
   - Nested routes via folder structure
   - Route groups `(groupName)`
   - Dynamic routes `[param]` and catch-all `[...slug]`
4. **Zero build step in development** — No webpack, no turbopack, no esbuild bundling. Source files are transformed on-the-fly per-request using esbuild's single-file transform API (fast, no bundling graph).
5. **TypeScript & JSX support** — `.tsx` and `.ts` files are transformed to JS on-the-fly by the server.
6. **React 19** — Use React 19 with the latest JSX transform.
7. **CSS support** — At minimum, CSS modules and plain CSS imports should work.
8. **Developer experience** — Clear error messages, fast feedback loop, minimal configuration.

## Scope

### In Scope
- Lightweight HTTP dev server (Node.js)
- On-the-fly TypeScript/JSX transformation (esbuild transform API, single-file, no bundling)
- File-system based routing matching Next.js App Router conventions
- Nested layouts
- `loading.tsx` (Suspense boundaries)
- `error.tsx` (Error boundaries)
- `not-found.tsx` handling
- Dynamic route segments `[param]` and catch-all `[...slug]`
- Route groups `(group)`
- Client-side navigation (SPA-style with pushState)
- Import maps for bare module specifiers (e.g. `import React from "react"`)
- HMR or live-reload for instant updates
- CSS modules and plain CSS imports
- Static asset serving from a `public/` directory
- A small example/demo app inside `app/` to validate functionality

### Out of Scope
- Production builds / bundling / optimization
- Server-side rendering (SSR)
- API routes / server actions / server-side data fetching
- Middleware
- `generateStaticParams` / static generation
- Image optimization
- Font optimization
- Internationalization
- `next.config.js` equivalent (keep it zero-config)
- Deployment tooling

## Architecture / Approach

### Tech Stack
- **Runtime**: Node.js (>= 20)
- **Package manager**: pnpm
- **Server**: Custom HTTP server using Node's built-in `http` module (or a thin wrapper like `polka`/`sirv` for simplicity)
- **Transform**: esbuild's `transform` API — single-file transform only, no bundle step. Each `.ts`/`.tsx` file is transformed to `.js` on request.
- **React**: React 19, loaded via import map pointing to ESM builds from esm.sh or a local copy
- **HMR/Live Reload**: WebSocket-based. The server watches for file changes via `fs.watch`/chokidar and sends reload signals to the client. Start with full-page live reload; HMR for React components can be a later enhancement.
- **Import Maps**: Generated by the server and injected into the HTML shell. Maps bare specifiers like `react`, `react-dom`, `react-dom/client` to their ESM URLs.
- **CSS**: CSS files served directly. CSS module files (`.module.css`) get a lightweight transform to produce a JS module exporting class name mappings.

### How It Works

1. **Server starts** — Reads the `app/` directory structure, builds a route table in memory. Serves an HTML shell for all page routes.
2. **HTML Shell** — A minimal HTML page that includes:
   - An import map (mapping bare specifiers to ESM URLs)
   - A `<script type="module">` that bootstraps the React app
   - A WebSocket client script for live reload
3. **Module requests** — When the browser requests a `.tsx`/`.ts` file, the server reads it from disk, runs `esbuild.transform()` to convert TSX/TS → JS, and serves it with `Content-Type: application/javascript`. Results are cached in memory (invalidated on file change).
4. **Route resolution** — The client-side router reads the route table (injected as JSON or fetched from the server) and dynamically imports the appropriate `page.tsx`, wrapped in its `layout.tsx` chain.
5. **File watching** — A file system watcher monitors `app/` and other source directories. On change, the in-memory transform cache is invalidated, and a WebSocket message tells the browser to reload the affected module (or full page).

### Directory Structure (Target)

```
no-build-next/
  package.json
  server/                  # Dev server source code
    index.ts               # Entry point — starts HTTP server
    router.ts              # Scans app/ dir, builds route table
    transform.ts           # esbuild transform + caching
    watcher.ts             # File watching + WebSocket reload
    html.ts                # HTML shell generation
    css.ts                 # CSS / CSS module handling
    import-map.ts          # Import map generation
  client/                  # Client-side runtime
    bootstrap.tsx          # Entry point — mounts React app
    router.tsx             # Client-side router component
    error-boundary.tsx     # Error boundary wrapper
    layout-renderer.tsx    # Renders nested layout chain
    link.tsx               # <Link> component for client nav
  app/                     # Demo app (also serves as test fixture)
    layout.tsx             # Root layout
    page.tsx               # Home page
    about/
      page.tsx             # /about page
    blog/
      layout.tsx           # Blog layout
      page.tsx             # /blog page
      [slug]/
        page.tsx           # /blog/:slug page
    loading.tsx            # Global loading state
    error.tsx              # Global error boundary
    not-found.tsx          # 404 page
  public/                  # Static assets
```

## Milestones / Phases

### Phase 1: Core Server Foundation
- Set up project dependencies (esbuild, react, react-dom)
- Create the HTTP server that serves an HTML shell
- Implement on-the-fly `.ts`/`.tsx` transform via esbuild
- Serve transformed modules with correct MIME types
- Generate and inject import maps for React dependencies
- Verify: a single `app/page.tsx` renders in the browser

### Phase 2: File-System Routing
- Scan `app/` directory to build route table
- Support `page.tsx` convention for route endpoints
- Support nested folders as nested routes
- Support dynamic segments `[param]`
- Support catch-all segments `[...slug]`
- Support route groups `(group)` (ignored in URL path)
- Expose route table to client-side router

### Phase 3: Layouts & Nested Rendering
- Implement `layout.tsx` convention — nested layout chain
- Client-side layout renderer that wraps pages in their layout hierarchy
- Root layout (`app/layout.tsx`) wraps all pages
- Layouts persist across navigations within their segment

### Phase 4: Loading, Error, and Not-Found States
- `loading.tsx` → Suspense boundary for each route segment
- `error.tsx` → Error boundary for each route segment
- `not-found.tsx` → Shown when no route matches
- Wire these into the client-side rendering pipeline

### Phase 5: Client-Side Navigation
- Implement `<Link>` component for SPA-style navigation
- pushState/popState handling
- Dynamic module imports on route change
- Preserve layout state across navigations

### Phase 6: Live Reload / HMR
- File watcher (chokidar or fs.watch) on source directories
- WebSocket server alongside HTTP server
- On file change: invalidate transform cache, notify client
- Client reloads affected modules (start with full page reload, improve to granular later)

### Phase 7: CSS Support
- Serve plain `.css` files directly
- CSS module support (`.module.css` → JS module with class name map)
- Inject CSS via `<link>` tags or JS-based injection

### Phase 8: Demo App & Polish
- Build out the demo app in `app/` to exercise all features
- Test all routing patterns (nested, dynamic, catch-all, groups)
- Test layouts, loading, error, not-found
- Test live reload workflow
- Ensure startup time < 1s
- Ensure reload time < 1s
- Clean up error messages and developer experience

## Detailed Requirements

### Dev Server (`server/`)
- **Entry point** (`server/index.ts`): Start HTTP server on a configurable port (default 3000). Print startup time to console.
- **Transform** (`server/transform.ts`): Use `esbuild.transform()` with `loader: 'tsx'`, `format: 'esm'`, `jsx: 'automatic'`, `jsxImportSource: 'react'`. Cache results keyed by file path + mtime. Invalidate on file change.
- **Router** (`server/router.ts`): Recursively scan `app/` for `page.tsx` files. Build route patterns. Match incoming URL paths to routes. Return 404 for no match.
- **HTML** (`server/html.ts`): Generate HTML shell with `<!DOCTYPE html>`, import map `<script type="importmap">`, module bootstrap `<script type="module" src="/client/bootstrap.tsx">`, and WebSocket live-reload client.
- **Watcher** (`server/watcher.ts`): Watch `app/`, `client/`, `server/` directories. On change, invalidate transform cache entry. Send WebSocket message with changed file path.
- **Import Map** (`server/import-map.ts`): Generate import map JSON mapping `react` → ESM URL, `react-dom` → ESM URL, `react-dom/client` → ESM URL. Use esm.sh CDN or vendored copies.
- **CSS** (`server/css.ts`): Serve `.css` files with correct content type. For `.module.css`, parse class names and generate a JS module that exports the class name mapping and injects the CSS.
- **Static files**: Serve files from `public/` directory at root path.

### Client Runtime (`client/`)
- **Bootstrap** (`client/bootstrap.tsx`): Import React and ReactDOM. Fetch route table from server. Render `<Router>` component into `#root`.
- **Router** (`client/router.tsx`): Match current URL to route table. Dynamically import the matched `page.tsx` and its layout chain. Handle pushState/popState. Re-render on navigation.
- **Layout Renderer** (`client/layout-renderer.tsx`): Given a route match, render the nested layout chain wrapping the page component. Persist layout state across navigations within the same segment.
- **Error Boundary** (`client/error-boundary.tsx`): React error boundary component. Used to wrap route segments that have an `error.tsx`.
- **Link** (`client/link.tsx`): `<Link href="/path">` component. Intercepts clicks, uses pushState, triggers router re-render.

### Demo App (`app/`)
- Root layout with basic HTML structure (html, body tags handled at server level; root layout provides app wrapper)
- Home page with links to other pages
- About page (simple static)
- Blog section with nested layout
- Blog post dynamic route `[slug]`
- Loading, error, and not-found pages

### Validation with Real Next.js App

Use `/Users/matt/code/brew-cms/` as an example Next.js app to validate the framework works with real-world code. This is an existing Next.js project that should be used to:
- Test that file-system routing correctly parses the existing `app/` directory structure
- Verify that layouts, pages, loading states, and error boundaries work as expected
- Identify edge cases and missing features that the simple demo app doesn't exercise
- Ensure the transform pipeline handles real-world TypeScript/TSX patterns

When testing with brew-cms:
1. Point the dev server at the brew-cms `app/` directory (via config or symlink)
2. Verify routes are discovered and accessible
3. Check that client components render correctly
4. Note any unsupported features or patterns that cause failures

## Constraints & Assumptions

- **Node.js >= 20** required (for built-in fetch, stable ESM support, performance)
- **pnpm** as package manager (already configured in `package.json`)
- **Browser support**: Modern evergreen browsers only (Chrome, Firefox, Safari, Edge — latest versions). No IE11 or legacy support needed.
- **esbuild** is used only for its `transform()` API, never for bundling. This keeps transforms fast (microseconds per file) and avoids dependency graph resolution.
- **React 19** — Assumes React 19 ESM builds are available via CDN (esm.sh) or npm.
- **No production build** — This project only targets development. Production bundling is out of scope.
- **Single-page app** — The server serves the same HTML shell for all routes. Routing is client-side only.
- **No SSR** — Pages are rendered entirely on the client. This means no server components, no streaming, no RSC.
- **TypeScript source files** — The server itself can be written in TypeScript and run via `tsx` or `ts-node`, or written in plain JS. The key constraint is that the `app/` and `client/` files are TypeScript/TSX and transformed on-the-fly.
